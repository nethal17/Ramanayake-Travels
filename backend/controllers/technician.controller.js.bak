// Send password after email verification
export const sendPasswordAfterVerification = async (userId) => {
    try {
        const user = await User.findById(userId);
        if (!user || !user.isVerified) {
            return;
        }

        const password = user.twoStepVerificationCode; // Retrieve the stored password
        if (!password) return;

        const emailContent = `
            <h2>Your Login Credentials - Ramanayake Travels</h2>
            <p>Dear ${user.name},</p>
            <p>Thank you for verifying your email. Here are your login credentials:</p>
            <div style="background-color: #f8f9fa; padding: 20px; border-radius: 5px; margin: 20px 0;">
                <p><strong>Email:</strong> ${user.email}</p>
                <p><strong>Password:</strong> ${password}</p>
            </div>
            <p>Please keep these credentials safe and change your password after your first login.</p>
            <p>You can now log in to the system using these credentials.</p>
            <br>
            <p>Best regards,</p>
            <p>Ramanayake Travels Team</p>
        `;

        await sendEmail({
            to: user.email,
            subject: 'Your Login Credentials - Ramanayake Travels',
            html: emailContent
        });

        // Clear the temporary password
        user.twoStepVerificationCode = null;
        await user.save();

    } catch (error) {
        console.error('Send password email error:', error);
    }
};
import User from '../models/user.model.js';
import Technician from '../models/technician.model.js';
import bcrypt from 'bcrypt';
import crypto from 'crypto';
import fs from 'fs';
import path from 'path';
import { sendEmail } from '../lib/nodemailer.js';

// Generate random password
const generatePassword = () => {
    const length = 8;
    const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*";
    let password = "";
    for (let i = 0; i < length; i++) {
        password += charset.charAt(Math.floor(Math.random() * charset.length));
    }
    return password;
};

// Create technician
export const createTechnician = async (req, res) => {
    try {
        const { name, email, age, address, phone, specialization, experience } = req.body;

        // Check if user already exists
        const existingUser = await User.findOne({ 
            $or: [{ email }, { phone }] 
        });
        
        if (existingUser) {
            return res.status(400).json({
                success: false,
                message: "User with this email or phone already exists"
            });
        }

        // Check if certification file is uploaded
        if (!req.file) {
            return res.status(400).json({
                success: false,
                message: "Certification document is required"
            });
        }

        // Parse dates from request body
        const certIssueDate = new Date(req.body.certIssueDate);
        const certExpiryDate = req.body.certExpiryDate ? new Date(req.body.certExpiryDate) : null;

        // Generate auto password and verification token
        const autoPassword = generatePassword();
        const hashedPassword = await bcrypt.hash(autoPassword, 12);
        const verificationToken = crypto.randomBytes(32).toString('hex');

        // Create user
        const user = new User({
            name,
            email,
            phone,
            password: hashedPassword,
            role: 'technician',
            verificationToken,
            isVerified: false
        });

        const savedUser = await user.save();

        // Create technician details
        const technician = new Technician({
            userId: savedUser._id,
            age: parseInt(age),
            address,
            specialization,
            experience: parseInt(experience),
            certification: {
                certName: req.body.certName,
                issueDate: certIssueDate,
                expiryDate: certExpiryDate,
                certificateImage: req.file.filename
            }
        });

        await technician.save();

        // Send verification email
        const verificationLink = `http://localhost:5001/api/auth/verify-email/${verificationToken}`;
        
        const emailContent = `
            <h2>Welcome to Ramanayake Travels!</h2>
            <p>Dear ${name},</p>
            <p>You are now a technician in our system. Please verify your email address to complete your registration.</p>
            <p>Click the link below to verify your email:</p>
            <a href="${verificationLink}" style="background-color: #4CAF50; color: white; padding: 14px 20px; text-decoration: none; border-radius: 4px;">Verify Email</a>
            <p>If the button doesn't work, copy and paste this link into your browser:</p>
            <p>${verificationLink}</p>
            <p>After verification, you will receive your login credentials.</p>
            <br>
            <p>Best regards,</p>
            <p>Ramanayake Travels Team</p>
        `;

        await sendEmail({
            to: email,
            subject: 'Welcome to Ramanayake Travels - Please Verify Your Email',
            html: emailContent
        });

        // Store auto-generated password temporarily
        savedUser.twoStepVerificationCode = autoPassword;
        await savedUser.save();

        res.status(201).json({
            success: true,
            message: "Technician created successfully. Verification email sent.",
            data: {
                id: savedUser._id,
                name: savedUser.name,
                email: savedUser.email,
                phone: savedUser.phone,
                role: savedUser.role
            }
        });

    } catch (error) {
        console.error('Create technician error:', error);
        res.status(500).json({
            success: false,
            message: "Failed to create technician",
            error: error.message
        });
    }
};

// Get all technicians
export const getAllTechnicians = async (req, res) => {
    try {
        const technicians = await Technician.find()
            .populate('userId', 'name email phone isVerified createdAt')
            .sort({ createdAt: -1 });

        res.status(200).json({
            success: true,
            data: technicians
        });
    } catch (error) {
        console.error('Get technicians error:', error);
        res.status(500).json({
            success: false,
            message: "Failed to fetch technicians",
            error: error.message
        });
    }
};

// Get technician by ID
export const getTechnicianById = async (req, res) => {
    try {
        const { id } = req.params;
        
        const technician = await Technician.findById(id)
            .populate('userId', 'name email phone isVerified createdAt');

        if (!technician) {
            return res.status(404).json({
                success: false,
                message: "Technician not found"
            });
        }

        res.status(200).json({
            success: true,
            data: technician
        });
    } catch (error) {
        console.error('Get technician error:', error);
        res.status(500).json({
            success: false,
            message: "Failed to fetch technician",
            error: error.message
        });
    }
};

// Update technician status
export const updateTechnicianStatus = async (req, res) => {
    try {
        const { id } = req.params;
        const { status } = req.body;

        const technician = await Technician.findByIdAndUpdate(
            id,
            { status },
            { new: true, runValidators: true }
        ).populate('userId', 'name email phone');

        if (!technician) {
            return res.status(404).json({
                success: false,
                message: "Technician not found"
            });
        }

        res.status(200).json({
            success: true,
            message: "Technician status updated successfully",
            data: technician
        });
    } catch (error) {
        console.error('Update technician status error:', error);
        res.status(500).json({
            success: false,
            message: "Failed to update technician status",
            error: error.message
        });
    }
};

// Update technician details
export const updateTechnician = async (req, res) => {
    try {
        const { id } = req.params;
        const { name, email, age, address, phone, specialization, experience } = req.body;

        // Find the technician
        const technician = await Technician.findById(id).populate('userId');
        if (!technician) {
            return res.status(404).json({
                success: false,
                message: "Technician not found"
            });
        }

        // Check if email or phone is being changed and already exists for another user
        if (email !== technician.userId.email || phone !== technician.userId.phone) {
            const existingUser = await User.findOne({
                $and: [
                    { _id: { $ne: technician.userId._id } }, // Exclude current user
                    { $or: [{ email }, { phone }] }
                ]
            });
            
            if (existingUser) {
                return res.status(400).json({
                    success: false,
                    message: "User with this email or phone already exists"
                });
            }
        }

        // Parse dates from request body
        const certIssueDate = req.body.certIssueDate ? new Date(req.body.certIssueDate) : technician.certification.issueDate;
        const certExpiryDate = req.body.certExpiryDate ? new Date(req.body.certExpiryDate) : technician.certification.expiryDate;

        // Prepare update data for technician
        const technicianUpdateData = {
            age: parseInt(age),
            address,
            specialization: specialization || technician.specialization,
            experience: parseInt(experience),
            'certification.certName': req.body.certName || technician.certification.certName,
            'certification.issueDate': certIssueDate,
            'certification.expiryDate': certExpiryDate
        };

        // Handle certificate image update
        if (req.file) {
            // Delete old certificate image if it exists
            if (technician.certification.certificateImage) {
                const oldCertPath = path.join(process.cwd(), 'uploads', technician.certification.certificateImage);
                if (fs.existsSync(oldCertPath)) {
                    fs.unlinkSync(oldCertPath);
                }
            }
            technicianUpdateData['certification.certificateImage'] = req.file.filename;
        }

        // Update user details
        await User.findByIdAndUpdate(
            technician.userId._id,
            { name, email, phone },
            { new: true, runValidators: true }
        );

        // Update technician details
        const updatedTechnician = await Technician.findByIdAndUpdate(
            id,
            technicianUpdateData,
            { new: true, runValidators: true }
        ).populate('userId', 'name email phone isVerified');

        res.status(200).json({
            success: true,
            message: "Technician updated successfully",
            data: updatedTechnician
        });

    } catch (error) {
        console.error('Update technician error:', error);
        res.status(500).json({
            success: false,
            message: "Failed to update technician",
            error: error.message
        });
    }
};

// Delete technician
export const deleteTechnician = async (req, res) => {
    try {
        const { id } = req.params;

        const technician = await Technician.findById(id);
        if (!technician) {
            return res.status(404).json({
                success: false,
                message: "Technician not found"
            });
        }

        // Delete certificate image
        const certImagePath = path.join(process.cwd(), 'uploads', technician.certification.certificateImage);
        if (fs.existsSync(certImagePath)) {
            fs.unlinkSync(certImagePath);
        }

        // Delete technician record
        await Technician.findByIdAndDelete(id);
        
        // Delete user record
        await User.findByIdAndDelete(technician.userId);

        res.status(200).json({
            success: true,
            message: "Technician deleted successfully"
        });
    } catch (error) {
        console.error('Delete technician error:', error);
        res.status(500).json({
            success: false,
            message: "Failed to delete technician",
            error: error.message
        });
    }
};

// Get technician profile - for technician users to see their own profile
export const getTechnicianProfile = async (req, res) => {
    try {
        // Get the logged-in technician's ID
        const userId = req.user._id;
        
        console.log('Getting technician profile for user:', userId);
        
        // Find technician details by userId
        const technician = await Technician.findOne({ userId })
            .populate('userId', 'name email phone');
        
        if (!technician) {
            console.log('No technician profile found for userId:', userId);
            return res.status(404).json({
                success: false,
                message: "Technician profile not found"
            });
        }
        
        console.log('Technician profile found:', technician._id);
        
        return res.status(200).json({
            success: true,
            ...technician.toObject()
        });
    } catch (error) {
        console.error("Error getting technician profile:", error);
        return res.status(500).json({
            success: false,
            message: "Error retrieving technician profile",
            error: error.message
        });
    }
};

// Update technician availability
export const updateTechnicianAvailability = async (req, res) => {
    try {
        // Get the logged-in technician's ID
        const userId = req.user._id;
        
        // Get availability from request body
        const { availability } = req.body;
        
        if (typeof availability !== 'boolean') {
            return res.status(400).json({
                success: false,
                message: "Availability must be a boolean value"
            });
        }
        
        // Find and update technician availability
        const technician = await Technician.findOneAndUpdate(
            { userId },
            { availability },
            { new: true }
        );
        
        if (!technician) {
            return res.status(404).json({
                success: false,
                message: "Technician profile not found"
            });
        }
        
        return res.status(200).json({
            success: true,
            message: `Technician availability updated to ${availability ? 'available' : 'unavailable'}`,
            technician
        });
    } catch (error) {
        console.error("Error updating technician availability:", error);
        return res.status(500).json({
            success: false,
            message: "Error updating technician availability",
            error: error.message
        });
    }
};
